\documentclass[a4paper]{article}

\usepackage{amsmath,amsfonts}

\renewcommand{\tilde}[1]{\widetilde{#1}}

\begin{document}

\section*{Technical documentation of \texttt{mc\_bayer\_roughbergomi}}
\label{sec:techn-docum-verbmc_b}

\subsection*{Background}
\label{sec:background}

\texttt{mc\_bayer\_roughbergomi} computes the price of a European call option in
the rough Bergomi model (Bayer, Friz and Gatheral) using Monte Carlo
simulation based on the hybrid scheme of Bennedsen, Lunde and Pakkanen.

The rough Bergomi model is described by the dynamics
\begin{gather*}
  dS_t = \sqrt{v_t} S_t dZ_t,\\
  v_t = \xi_0(t) \exp\left( \eta \tilde{W}_t - \frac{1}{2} \eta^2 t^{2H} \right),
\end{gather*}
where $W, Z$ denote two \emph{correlated} standard Brownian motions--with
correlation $\rho$--, $\xi_0$ denotes the forward variance curve\footnote{In
  the current implementation, we assume $\xi_0$ to be constant.} at time $t$,
$\eta > 0$ is interpreted as a volatility of volatility parameter. More
interestingly, for $0 < H < 1$ we have
\begin{equation*}
  \tilde{W}_t = \int_0^t K(t,s) dW_s, \quad K(t,s) = \sqrt{2H} (t-s)^{H - 1/2}.
\end{equation*}
This defines a variant of the fractional Brownian motion, sometimes called
``Riemann-Liouville fractional Brownian motion'', which is not the standard
fBm. It can be simulated either by Cholesky factorization of the covariance
matrix, or by the above mentioned \emph{hybrid scheme}. Without loss of
generality, we shall assume $S_0 = 1$ in what follows.

Conditioning on the $\sigma$-algebra generated by $W$, we have
\begin{multline*}
  C_{RB}\left( T, K \right) = E\left[ \left(S_T - K \right)^+ \right] =\\
  E\left[C_{BS}\left( S_0 = e^{\rho \int_0^T \sqrt{v_t} dW_t - \frac{1}{2}
        \rho^2 \int_0^T v_t dt},\ K = K, \ T = 1, \ \sigma^2 = (1-\rho^2)
      \int_0^T v_t dt \right) \right],
\end{multline*}
where $C_{BS}$ denotes the Black-Scholes price. Hence, we need to simulate the
random variables
\begin{equation*}
  \int_0^T \sqrt{v_t} dW_t, \quad \int_0^T v_t dt.
\end{equation*}

\subsection*{Implementation}
\label{sec:implementation}

The key challenge of the algorithm is the (joint) simulation of $W$ and
$\tilde{W}$. Indeed, the above integrals will be discretized by simple
left-point rules based on a uniform time-grid $0 = t_0 < t_1 < \cdots < t_N =
T$. As $v$ is directly defined in terms of $\tilde{W}$, we hence only need to
simulate the Gaussian random vectors
\begin{equation*}
  \left( W_{t_1}, \ldots, W_{t_N} \right) \text{ and } \left( \tilde{W}_{t_1},
    \ldots, \tilde{W}_{t_N} \right).
\end{equation*}
We now explain the function \texttt{compute\_Wtilde}, which is responsible to
simulate $\tilde{W}$. In the context of this function, time is re-scaled to $T
= 1$, and the hybrid scheme (for $\kappa = 1$) requires two (independent) standard Gaussian
random vectors of size $N$ as input, \texttt{W1} and \texttt{W1perp}. The
variable \texttt{W1} corresponds to the random vector $\left( W_{t_1}, \ldots,
  W_{t_N} \right)$ by
\begin{equation*}
  W1[i] = \sqrt{N} \left( W_{t_{i+1}} - W_{t_i} \right).\footnote{Recall the
  re-scaling $T = 1$ here!}
\end{equation*}
\texttt{compute\_Wtilde} computes a variable \texttt{Wtilde} which directly
corresponds to the random vector $\left( \tilde{W}_{t_1}, \ldots,
  \tilde{W}_{t_N} \right)$---again noting the re-scaling.

Computationally, the most demanding work in \texttt{compute\_Wtilde} is the
computation of a discrete convolution of the array \texttt{W1} with an array
\texttt{Gamma}, which is done by FFT (lines 104--114 in rBergomi.cpp). The
steps are rather self-explaining, apart from the rather confusing steps
required by the library FFTW used for performing the FFT. In short, the
command \texttt{fftw\_execute(fPlanX)} computes the (forward) DFT of the
complex array \texttt{xC} and saves the result in the complex array
\texttt{xHat}--and similarly for \texttt{fPlanY}. On the other hand,
\texttt{fftw\_execute(fPlanZ)} computes the inverse DFT of the complex array
\texttt{zHat} and saves the result in the complex array \texttt{zC}.

As far as my understanding of FFTW is concerned, the following happens
underneath. The scenario is the following: assume we want to compute the DFT
$\hat{x}$ of many different complex vectors $x$, each of size $n$---this is
true in our case. We first allocate two arrays of type \texttt{fftw\_complex}
of length $n$ each, let us call them \texttt{xC} and \texttt{xHat},
respectively. Now we generate an \emph{FFT-plan} using the function
\texttt{fftw\_plan\_dft\_1d}. In this FFT-plan both the type of the DFT
(forward or inverse) and the length of the vectors involved and even the
memory location of the arrays representing those vectors are hard-coded. The
idea of this step is (apparently) that it allows FFTW to do various
optimizations based on the specific architecture, dimension and memory layout
involved. After an FFT-plan was generated, \texttt{fftw\_execute} simply
computes the DFT of whatever is saved in \texttt{xC} and stores the result in
\texttt{xHat}.

Note that constructing an FFT-plan can be rather costly, which is why all the
complex arrays and the FFT-plans are only generated once and then passed on to
the auxiliary functions for computations.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
